<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tessellate Game (Corner Click)</title>
    <style>
         :root {
            --bg-color: #1a1a2e;
            --header-color: #16213e;
            --text-color: #e3e3e3;
            --accent-color: #0f3460;
            --red-color: #e94560;
            --blue-color: #3f72af;
            --grid-color: #e3e3e3;
            --empty-bg: #37474f; 
            --out-of-play-bg: #2c3a47;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: var(--bg-color);
            color: var(--text-color);
            touch-action: manipulation; 
            min-height: 100vh;
        }

        header {
            width: 100%;
            background-color: var(--header-color);
            padding: 15px 0;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            margin-bottom: 20px;
        }

        h1 {
            margin: 0;
            font-size: clamp(24px, 5vw, 32px); 
            letter-spacing: 1.5px;
            text-transform: uppercase;
        }

        .game-status {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 15px;
            width: 90%;
            max-width: 600px;
        }

        #score-display {
            font-size: clamp(18px, 4vw, 24px);
            margin: 10px 0;
            font-weight: bold;
            border-radius: 12px;
            padding: 12px 20px;
            background-color: var(--accent-color);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            text-align: center;
        }

        #turn-indicator {
            font-size: clamp(16px, 3.5vw, 20px);
            margin: 8px 0;
            font-weight: bold;
            text-align: center;
        }

        #game-container {
            position: relative;
            margin: 10px auto;
             width: 95%; 
             max-width: 600px; 
             aspect-ratio: 1 / 1;
        }

        canvas {
            display: block;
            background-color: var(--empty-bg);
            box-shadow: 0 6px 15px rgba(0,0,0,0.4);
            border-radius: 8px;
            width: 100%; 
            height: 100%; 
        }

        #controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
            max-width: 600px;
            padding: 0 10px; 
            box-sizing: border-box;
        }

        button {
            padding: 12px 20px; 
            font-size: clamp(14px, 3vw, 18px); 
            border: none;
            border-radius: 8px;
            background-color: var(--accent-color);
            color: var(--text-color);
            cursor: pointer;
            flex: 1 1 140px; 
            min-width: 140px;
            transition: all 0.2s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            text-align: center;
        }

        button:hover {
            background-color: #1b4f8d;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.3);
        }

        button:active {
            transform: translateY(1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .red-text {
            color: var(--red-color);
            text-shadow: 0 0 8px rgba(233, 69, 96, 0.4);
        }

        .blue-text {
            color: var(--blue-color);
            text-shadow: 0 0 8px rgba(63, 114, 175, 0.4);
        }

        footer {
            margin-top: auto;
            padding-top: 20px;
            text-align: center;
            font-size: 14px;
            color: #aaa;
            padding: 10px;
            width: 100%;
        }

        .rules {
            max-width: 600px;
            margin: 15px auto;
            background-color: var(--header-color);
            padding: 15px;
            border-radius: 8px;
            display: none; 
             width: 90%;
        }

        .rules h2 {
            margin-top: 0;
        }
         .rules ul {
             padding-left: 20px;
         }
         .rules li {
             margin-bottom: 8px;
         }
         .rule-details {
             font-style: italic;
             margin-top: 10px;
             padding: 10px;
             background-color: rgba(0,0,0,0.1);
             border-radius: 4px;
         }
    </style>
</head>
<body>
    <header>
        <h1>Tessellate</h1>
    </header>

    <div class="game-status">
        <div id="score-display">
            <span class="red-text">Red: 1</span> | <span class="blue-text">Blue: 1</span>
        </div>
        <div id="turn-indicator">Current Turn: <span class="red-text">Red</span></div>
    </div>

    <div id="game-container">
        <canvas id="game-board"></canvas>
    </div>

    <div class="rules" id="rules-panel">
         <p>Two players, red and blue, place triangular tiles on the board, one after another.</p>
         <p>Placing a tile fills one triangular half of a score radiating from that corner.</p>
         <p>Using a corner prevents anyone from using the two adjacent corners in the square.</p>
         <p>Your score is the <strong>product</strong> of the sizes (# of triangles) of all your connected regions.</p>
         <p>Connected regions are formed by tiles of the same color that share a full edge.</p>
         <p>The game ends when all possible tile slots (50 for a 5x5 visual grid) are filled.</p>
         <p>The player with the highest score wins.</p>
     </div>

    <div id="controls">
        <button id="new-game-btn">New Game (Local)</button>
        <button id="rules-btn">Rules</button>
        <button id="play-online-btn">Play Online</button>
    </div>
    <div id="online-options" style="display:none; margin-top:10px; text-align: center; padding: 10px; background-color: var(--header-color); border-radius: 8px;">
        <button id="create-game-btn" style="margin-right: 10px; padding: 10px 15px; font-size: clamp(13px, 2.5vw, 16px);">Create New Game</button>
        <input type="text" id="session-id-input" placeholder="Enter Session ID" style="padding: 10px; margin-right: 10px; border-radius: 5px; border: 1px solid #ccc; font-size: clamp(13px, 2.5vw, 16px);">
        <button id="join-game-btn" style="padding: 10px 15px; font-size: clamp(13px, 2.5vw, 16px);">Join Game</button>
    </div>
    <div id="server-message-display" style="margin-top: 15px; text-align: center; font-weight: bold; min-height: 20px; padding: 5px; color: var(--text-color);"></div>

     
    <footer>
        Â© 2025 Max Cembalest
    </footer>
    <script>
        const RED = 0;
        const BLUE = 1;
        const EMPTY = 2;
        const OUT_OF_PLAY = 3;
        const VISUAL_GRID_SIZE = 5;
        const LOGICAL_GRID_SIZE = VISUAL_GRID_SIZE * 2; 
        const TOTAL_TILES = VISUAL_GRID_SIZE * VISUAL_GRID_SIZE * 2; 
        let showPreview = true;
        const canvas = document.getElementById('game-board');
        const ctx = canvas.getContext('2d');
        let visualCellSize = 0; 
        let logicalCellSize = 0;
        const colors = {
            [RED]: { normal: '#e94560', preview: '#ff96a6' },
            [BLUE]: { normal: '#3f72af', preview: '#94b8ff' },
            background: '#37474f',
            gridLines: '#e3e3e3',
        };
        let board = [];
        let currentTurn = RED;
        let scores = { [RED]: 1, [BLUE]: 1 }; // Scores for the Tessellate game are products
        let gameOver = false;
        let hoverPosition = null; 
        let placedTilesCount = 0;

        // Multiplayer variables
        let socket = null;
        let sessionId = null;
        let playerId = null; // 0 for Red, 1 for Blue. Server will assign.
        let isMultiplayerGame = false;
        let serverMessageDisplay = null; // Will be initialized in DOMContentLoaded. Used for server msgs.

        function initializeBoard() {
            board = Array(LOGICAL_GRID_SIZE).fill(null).map(() =>
                Array(LOGICAL_GRID_SIZE).fill(EMPTY)
            );
            currentTurn = RED;
            scores = { [RED]: 1, [BLUE]: 1 };
            hoverPosition = null;
            gameOver = false;
            placedTilesCount = 0;
            console.log(`Board Initialized (${LOGICAL_GRID_SIZE}x${LOGICAL_GRID_SIZE} Logical Grid)`);
        }

        function setupCanvas() {
            const container = document.getElementById('game-container');
            const containerSize = container.offsetWidth;
            canvas.width = containerSize;
            canvas.height = containerSize;
            visualCellSize = canvas.width / VISUAL_GRID_SIZE;
            logicalCellSize = visualCellSize / 2; // Or canvas.width / LOGICAL_GRID_SIZE
            console.log(`Canvas Setup: Size=${canvas.width}x${canvas.height}, VisualCell=${visualCellSize}, LogicalCell=${logicalCellSize}`);
            drawBoard();
        }

        function drawBoard() {
            ctx.fillStyle = colors.background;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            for (let r = 0; r < LOGICAL_GRID_SIZE; r++) {
                for (let c = 0; c < LOGICAL_GRID_SIZE; c++) {
                    const tileState = board[r][c];
                    if (tileState === RED || tileState === BLUE) {
                        drawTile(r, c, tileState, false);
                    }
                }
            }
            ctx.strokeStyle = colors.gridLines;
            ctx.lineWidth = 1.5;
            for (let i = 0; i <= VISUAL_GRID_SIZE; i++) {
                // Vertical
                ctx.beginPath();
                ctx.moveTo(i * visualCellSize, 0);
                ctx.lineTo(i * visualCellSize, canvas.height);
                ctx.stroke();
                // Horizontal
                ctx.beginPath();
                ctx.moveTo(0, i * visualCellSize);
                ctx.lineTo(canvas.width, i * visualCellSize);
                ctx.stroke();
            }
            if (showPreview && hoverPosition && !gameOver && isPlayable(hoverPosition.r, hoverPosition.c)) {
                 drawTile(hoverPosition.r, hoverPosition.c, currentTurn, true);
            }
        }

        function drawTile(r, c, color, isPreview) {
            const visualY = Math.floor(r / 2);
            const visualX = Math.floor(c / 2);
            const x0 = visualX * visualCellSize;
            const y0 = visualY * visualCellSize;
            const x1 = (visualX + 1) * visualCellSize;
            const y1 = (visualY + 1) * visualCellSize;
            const tl = { x: x0, y: y0 }; 
            const tr = { x: x1, y: y0 };
            const bl = { x: x0, y: y1 }; 
            const br = { x: x1, y: y1 }; 
            let points = [];
            const isRowEven = r % 2 === 0;
            const isColEven = c % 2 === 0;

            if (isRowEven && isColEven) {
                points = [tl, tr, bl];
            } else if (isRowEven && !isColEven) { 
                points = [tr, br, tl]; 
            } else if (!isRowEven && isColEven) { 
                points = [bl, tl, br];
            } else {
                points = [br, bl, tr];
            }
            ctx.fillStyle = isPreview ? colors[color].preview : colors[color].normal;
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            ctx.lineTo(points[1].x, points[1].y);
            ctx.lineTo(points[2].x, points[2].y);
            ctx.closePath();
            ctx.fill();
        }
        function isValidCoord(r, c) {
            return r >= 0 && r < LOGICAL_GRID_SIZE && c >= 0 && c < LOGICAL_GRID_SIZE;
        }
        function isPlayable(r, c) {
            return isValidCoord(r, c) && board[r][c] === EMPTY;
        }
        function addTile(r, c) {
            if (!isPlayable(r, c)) {
                console.error(`Internal Error: Attempted to play invalid move at logical corner (${r}, ${c})`);
                return false;
            }
            console.log(`Adding ${currentTurn === RED ? 'RED' : 'BLUE'} tile at corner (${r}, ${c})`);
            board[r][c] = currentTurn;
            placedTilesCount++;
            const c_adj = c + (c % 2 === 0 ? 1 : -1);
            if (isValidCoord(r, c_adj)) {
                 if (board[r][c_adj] === EMPTY) board[r][c_adj] = OUT_OF_PLAY;
            }
            const r_adj = r + (r % 2 === 0 ? 1 : -1);
             if (isValidCoord(r_adj, c)) {
                 if (board[r_adj][c] === EMPTY) board[r_adj][c] = OUT_OF_PLAY;
             }

            return true;
        }
        function calculateScore() {
            scores = { [RED]: 1, [BLUE]: 1 };
            const visited = Array(LOGICAL_GRID_SIZE).fill(null).map(() =>
                Array(LOGICAL_GRID_SIZE).fill(false)
            );
            for (let r = 0; r < LOGICAL_GRID_SIZE; r++) {
                for (let c = 0; c < LOGICAL_GRID_SIZE; c++) {
                    const color = board[r][c];
                    if ((color === RED || color === BLUE) && !visited[r][c]) {
                        const regionSize = dfs(r, c, color, visited);
                        if (regionSize > 0) {
                            scores[color] *= regionSize;
                             console.log(`Found ${color === RED ? 'RED' : 'BLUE'} region size ${regionSize} starting at (${r},${c}). New score prod: ${scores[color]}`);
                        }
                    }
                }
            }
            console.log(`Final Calculated Scores: RED=${scores[RED]}, BLUE=${scores[BLUE]}`);
        }

        function dfs(startR, startC, color, visited) {
            let size = 0;
            const stack = [[startR, startC]];
            while (stack.length > 0) {
                const [r, c] = stack.pop();
                if (isValidCoord(r, c) && board[r][c] === color && !visited[r][c]) {
                    visited[r][c] = true;
                    size++;
                    const neighbors = getNeighbors(r, c);
                    for (const [nr, nc] of neighbors) {
                        if (isValidCoord(nr, nc) && board[nr][nc] === color && !visited[nr][nc]) {
                             stack.push([nr, nc]);
                        }
                    }
                }
            }
            return size;
        }

        function getNeighbors(r, c) {
            const neighbors = [];
            const pow_neg1_r = (r % 2 === 0 ? 1 : -1);
            const pow_neg1_c = (c % 2 === 0 ? 1 : -1);
            const pow_neg1_r_plus_1 = ((r + 1) % 2 === 0 ? 1 : -1);
            const pow_neg1_c_plus_1 = ((c + 1) % 2 === 0 ? 1 : -1);
            const pow_neg1_r_c_1 = ((r + c + 1) % 2 === 0 ? 1 : -1);
            neighbors.push([r + pow_neg1_r, c + pow_neg1_c]);
            neighbors.push([r - 1, c - pow_neg1_r_c_1]);
            neighbors.push([r + 1, c + pow_neg1_r_c_1]);
            neighbors.push([r + pow_neg1_r_plus_1, c]);
            neighbors.push([r, c + pow_neg1_c_plus_1]);
            return neighbors.filter(([nr, nc]) => isValidCoord(nr, nc));
        }

        function checkGameOver() {
            if (placedTilesCount >= TOTAL_TILES) {
                console.log(`Board full (${placedTilesCount}/${TOTAL_TILES} tiles). Game Over!`);
                gameOver = true;
                calculateScore();
                updateScoreDisplay();
                updateTurnIndicator();
                showGameOverMessage();
                hoverPosition = null;
                canvas.style.cursor = 'default';
            } else {
                 gameOver = false;
            }
        }

         function showGameOverMessage() {
             let message;
             const redScore = scores[RED];
             const blueScore = scores[BLUE];
             if (redScore > blueScore) {
                 message = `Game Over! Red wins: ${redScore.toLocaleString()} to ${blueScore.toLocaleString()}`;
             } else if (blueScore > redScore) {
                 message = `Game Over! Blue wins: ${blueScore.toLocaleString()} to ${redScore.toLocaleString()}`;
             } else {
                 message = `Game Over! It's a tie: ${redScore.toLocaleString()}`;
             }
             console.log(message); // Original log for local game over
             // For multiplayer, serverMessageDisplay usually shows the definitive game over message.
             // This function is primarily for local game over scenarios.
             if (!isMultiplayerGame && serverMessageDisplay) { // Check serverMessageDisplay exists
                // If we want to also update turnIndicator for local games from here (it's also done in checkGameOver->updateTurnIndicator)
                // serverMessageDisplay.textContent = message; // This might be too verbose for local
             }
         }

         function updateTurnIndicator() {
            const turnIndicatorElement = document.getElementById('turn-indicator');
            if (!turnIndicatorElement) return; 

            if (gameOver) {
                let finalMessage = "Game Over - ";
                const redFinalScore = (typeof scores[RED] === 'number' && !isNaN(scores[RED])) ? scores[RED].toLocaleString() : 'N/A';
                const blueFinalScore = (typeof scores[BLUE] === 'number' && !isNaN(scores[BLUE])) ? scores[BLUE].toLocaleString() : 'N/A';

                if (isMultiplayerGame) { 
                    // Use server message if available and specific, otherwise determine from scores
                    if (serverMessageDisplay && (serverMessageDisplay.textContent.includes("wins") || serverMessageDisplay.textContent.includes("Tie") || serverMessageDisplay.textContent.includes("disconnected") || serverMessageDisplay.textContent.includes("lost"))) {
                        finalMessage = serverMessageDisplay.textContent; // Use the specific message from server
                    } else { // Fallback for multiplayer if serverMessageDisplay is not specific enough yet
                        if (scores[RED] > scores[BLUE]) finalMessage += `<span class="red-text">Red Wins!</span>`;
                        else if (scores[BLUE] > scores[RED]) finalMessage += `<span class="blue-text">Blue Wins!</span>`;
                        else finalMessage += "It's a Tie!";
                    }
                } else { // Local game: determine winner from scores
                    if (scores[RED] > scores[BLUE]) finalMessage += `<span class="red-text">Red Wins!</span> (${redFinalScore} to ${blueFinalScore})`;
                    else if (scores[BLUE] > scores[RED]) finalMessage += `<span class="blue-text">Blue Wins!</span> (${blueFinalScore} to ${redFinalScore})`;
                    else finalMessage += `It's a Tie! (${redFinalScore} each)`;
                }
                turnIndicatorElement.innerHTML = finalMessage;
                canvas.style.cursor = 'default';
            } else if (isMultiplayerGame) {
                const playerClientColor = playerId === RED ? "Red" : "Blue"; // The color this client is playing as
                const currentTurnColor = currentTurn === RED ? "Red" : "Blue"; // The color of the player whose turn it is
                const turnPlayerClass = currentTurn === RED ? "red-text" : "blue-text";
                if (playerId === currentTurn) {
                    turnIndicatorElement.innerHTML = `Your Turn (<span class="${turnPlayerClass}">${playerClientColor}</span>)`;
                    canvas.style.cursor = 'pointer';
                } else {
                    turnIndicatorElement.innerHTML = `Opponent's Turn (<span class="${turnPlayerClass}">${currentTurnColor}</span>)`;
                    canvas.style.cursor = 'not-allowed';
                }
            } else { // Local game
                const player = currentTurn === RED ? 'Red' : 'Blue';
                const playerClass = currentTurn === RED ? 'red-text' : 'blue-text';
                turnIndicatorElement.innerHTML = `Current Turn: <span class="${playerClass}">${player}</span>`;
                canvas.style.cursor = 'pointer';
            }
        }
         function updateScoreDisplay() {
             const scoreDisplay = document.getElementById('score-display');
             const redScoreStr = (typeof scores[RED] === 'number' && !isNaN(scores[RED])) ? scores[RED].toLocaleString() : 'Error';
             const blueScoreStr = (typeof scores[BLUE] === 'number' && !isNaN(scores[BLUE])) ? scores[BLUE].toLocaleString() : 'Error';
             scoreDisplay.innerHTML = `
                 <span class="red-text">Red: ${redScoreStr}</span> |
                 <span class="blue-text">Blue: ${blueScoreStr}</span>
             `;
         }
        function getCoordsFromEvent(event) {
             const rect = canvas.getBoundingClientRect();
             let clientX, clientY;
             if (event.touches && event.touches.length > 0) {
                 clientX = event.touches[0].clientX;
                 clientY = event.touches[0].clientY;
             } else {
                 clientX = event.clientX;
                 clientY = event.clientY;
             }
             const x = clientX - rect.left;
             const y = clientY - rect.top;
             return { x, y };
         }
         function getClickableCorner(x, y) {
             if (x < 0 || y < 0 || x >= canvas.width || y >= canvas.height) return null;
             // Return logical grid coordinates, clamped to be within the board
             const r_logical = Math.max(0, Math.min(LOGICAL_GRID_SIZE - 1, Math.floor(y / logicalCellSize)));
             const c_logical = Math.max(0, Math.min(LOGICAL_GRID_SIZE - 1, Math.floor(x / logicalCellSize)));
             
             // isPlayable checks if the specific logical corner is valid (EMPTY and within bounds)
             if (isPlayable(r_logical, c_logical)) { 
                 return { r: r_logical, c: c_logical };
             }
             return null; 
         }

         function handleClick(event) {
            if (isMultiplayerGame) {
                if (gameOver || !socket || socket.readyState !== WebSocket.OPEN || playerId !== currentTurn) {
                    if (playerId !== currentTurn && !gameOver && serverMessageDisplay) {
                        serverMessageDisplay.textContent = "Wait for your opponent's turn!";
                    } else if (gameOver && serverMessageDisplay) {
                        // Game over message should already be displayed by handleServerMessage or updateTurnIndicator
                    } else if ((!socket || socket.readyState !== WebSocket.OPEN) && serverMessageDisplay) {
                        serverMessageDisplay.textContent = "Not connected to server.";
                    }
                    return;
                }
                const { x, y } = getCoordsFromEvent(event);
                const clickResult = getClickableCorner(x, y); 

                if (clickResult) {
                    const { r, c } = clickResult;
                    console.log(`Multiplayer: Sending move: r=${r}, c=${c}, player_id=${playerId}, session_id=${sessionId}`);
                    // Server's server.py expects: session_id, player_id, and move (obj with r,c) at top level of data
                    socket.send(JSON.stringify({
                        type: 'make_move',
                        session_id: sessionId, 
                        player_id: playerId,
                        move: { r, c } 
                    }));
                    if(serverMessageDisplay) serverMessageDisplay.textContent = "Move sent. Waiting for server update...";
                    // Local board/turn NOT updated here. Wait for game_update from server.
                } else {
                    if (serverMessageDisplay) serverMessageDisplay.textContent = "Invalid click location or not playable.";
                }

            } else { // Local game logic (existing logic largely remains)
                if (gameOver) return;
                const { x, y } = getCoordsFromEvent(event);
                const clickResult = getClickableCorner(x, y); 
                if (clickResult) {
                    const { r, c } = clickResult;
                    // console.log(`Local Click -> Playable Corner (${r}, ${c})`);
                    const moveSuccessful = addTile(r, c); // addTile handles local board update & marks adjacent

                    if (moveSuccessful) {
                        calculateScore();     
                        updateScoreDisplay(); 
                        currentTurn = 1 - currentTurn; // Switch turn LOCALLY
                        updateTurnIndicator(); 
                        checkGameOver(); // Sets gameOver, calls showGameOverMessage, updates indicators
                        drawBoard();        
                        if (hoverPosition && hoverPosition.r === r && hoverPosition.c === c) {
                            hoverPosition = null; 
                            canvas.style.cursor = 'default';
                        }
                    }
                } else {
                    // console.log("Local Click is not on a playable logical corner.");
                }
            }
        }
         function handleMouseMove(event) {
             if (gameOver || !showPreview) {
                 if (hoverPosition !== null) {
                     hoverPosition = null;
                     canvas.style.cursor = 'default';
                     drawBoard();
                 }
                 return;
             }
             const { x, y } = getCoordsFromEvent(event);
             const potentialHover = getClickableCorner(x, y);
             const currentHoverStr = JSON.stringify(hoverPosition);
             const potentialHoverStr = JSON.stringify(potentialHover);
             if (currentHoverStr !== potentialHoverStr) {
                 hoverPosition = potentialHover;
                 canvas.style.cursor = hoverPosition ? 'pointer' : 'default';
                 drawBoard(); 
             }
         }

         function handleMouseOut() {
             if (hoverPosition !== null && !gameOver) {
                 hoverPosition = null;
                 canvas.style.cursor = 'default';
                 drawBoard();
             }
         }
        function resetGame() { 
            console.log("resetGame called. Current isMultiplayerGame state:", isMultiplayerGame);
            
            // This function is called to reset the board, scores, turn, etc.
            // It's used for starting a new local game, or by handleServerMessage when a new MP game is created/joined.
            initializeBoard(); // Resets board, scores to 1, currentTurn to RED, gameOver to false, placedTilesCount
            
            // If isMultiplayerGame is true here, it's because a multiplayer game is starting.
            // The serverMessageDisplay will be set by handleServerMessage.
            // If isMultiplayerGame is false, it's a local game reset.
            if (!isMultiplayerGame) { 
                 if (serverMessageDisplay) serverMessageDisplay.textContent = "New local game started.";
                 document.getElementById('new-game-btn').textContent = "New Game (Local)";
                 const onlineOpts = document.getElementById('online-options');
                 if(onlineOpts) onlineOpts.style.display = 'none'; 
                
                // Ensure online buttons are disabled if we are starting a local game and socket might be closed/null
                const createGameBtn = document.getElementById('create-game-btn');
                const joinGameBtn = document.getElementById('join-game-btn');
                if (!socket || socket.readyState !== WebSocket.OPEN) {
                    if (createGameBtn) createGameBtn.disabled = true;
                    if (joinGameBtn) joinGameBtn.disabled = true;
                } else { // Socket is open, but it's a local game
                    if (createGameBtn) createGameBtn.disabled = false; // Or true, if online panel is hidden
                    if (joinGameBtn) joinGameBtn.disabled = false; // Or true
                }
            }
            
            updateScoreDisplay(); 
            updateTurnIndicator(); 
            drawBoard();
            canvas.style.cursor = 'pointer'; 
        }

        function togglePreview() {
            showPreview = !showPreview;
             if (!showPreview && hoverPosition !== null) {
                 hoverPosition = null;
                 canvas.style.cursor = 'default';
                 drawBoard();
             } else if (showPreview) {
                 handleMouseMove({ clientX: -1, clientY: -1 });
             }
        }

        function toggleRules() {
            const rulesPanel = document.getElementById('rules-panel');
            rulesPanel.style.display = rulesPanel.style.display === 'block' ? 'none' : 'block';
        }

        // WebSocket and multiplayer game functions
        function connectWebSocket() {
            if (socket && (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING)) {
                console.log("WebSocket already connected or connecting.");
                if (serverMessageDisplay) serverMessageDisplay.textContent = "Already connected or attempting to connect.";
                return;
            }

            socket = new WebSocket('ws://localhost:8765');
            if (serverMessageDisplay) serverMessageDisplay.textContent = "Connecting to server...";
            console.log("Attempting to connect to WebSocket server...");

            socket.onopen = () => {
                console.log('WebSocket connection established.');
                if (serverMessageDisplay) serverMessageDisplay.textContent = 'Connected to server. Choose an option above.';
                // Enable online action buttons
                const createGameBtn = document.getElementById('create-game-btn');
                const joinGameBtn = document.getElementById('join-game-btn');
                if (createGameBtn) createGameBtn.disabled = false;
                if (joinGameBtn) joinGameBtn.disabled = false;
            };

            socket.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    console.log('Message from server: ', message);
                    handleServerMessage(message); // Defined in next step
                } catch (e) {
                    console.error("Failed to parse server message:", event.data, e);
                    if (serverMessageDisplay) serverMessageDisplay.textContent = "Received an invalid message from server.";
                }
            };

            socket.onclose = (event) => {
                console.log(`WebSocket connection closed. Code: ${event.code}, Reason: ${event.reason}`);
                const wasMultiplayerGameActive = isMultiplayerGame; // Check if a game was active
                isMultiplayerGame = false; // Reset multiplayer status
                socket = null; 
                
                if (serverMessageDisplay) serverMessageDisplay.textContent = 'Disconnected. You can play locally or try "Play Online" again.';
                
                const onlineOptionsDiv = document.getElementById('online-options');
                // if (onlineOptionsDiv) onlineOptionsDiv.style.display = 'block'; // Optionally show options
                
                document.getElementById('new-game-btn').textContent = "New Game (Local)";
                
                const createGameBtn = document.getElementById('create-game-btn');
                const joinGameBtn = document.getElementById('join-game-btn');
                if (createGameBtn) createGameBtn.disabled = true;
                if (joinGameBtn) joinGameBtn.disabled = true;

                if (wasMultiplayerGameActive && !gameOver) { 
                    gameOver = true; // Mark game as over due to disconnection
                    if(serverMessageDisplay) serverMessageDisplay.textContent = "Connection lost. The online game was interrupted.";
                }
                updateTurnIndicator(); 
                if (canvas) canvas.style.cursor = 'default'; 
            };

            socket.onerror = (error) => {
                console.error('WebSocket error: ', error);
                if (serverMessageDisplay) serverMessageDisplay.textContent = `Connection error. Ensure server is running. Try refreshing.`;
                socket = null;
            };
        }

        function initiateCreateGame() {
            if (!socket || socket.readyState !== WebSocket.OPEN) {
                if (serverMessageDisplay) serverMessageDisplay.textContent = "Not connected. Click 'Play Online' and wait for connection.";
                // Optionally, try to connect if socket is totally closed:
                // if (!socket || socket.readyState === WebSocket.CLOSED) connectWebSocket();
                return;
            }
            socket.send(JSON.stringify({ type: "create_game" }));
            if (serverMessageDisplay) serverMessageDisplay.textContent = "Creating game... Waiting for server response.";
        }

        function initiateJoinGame(joinId) {
            if (!joinId) {
                if (serverMessageDisplay) serverMessageDisplay.textContent = "Session ID cannot be empty.";
                return;
            }
            if (!socket || socket.readyState !== WebSocket.OPEN) {
                if (serverMessageDisplay) serverMessageDisplay.textContent = "Not connected. Click 'Play Online' and wait for connection.";
                return;
            }
            // Server's server.py expects session_id at top level of data for join_game
            socket.send(JSON.stringify({ type: "join_game", "session_id": joinId }));
            if (serverMessageDisplay) serverMessageDisplay.textContent = `Joining game ${joinId}... Waiting for server response.`;
        }

        function handleServerMessage(message) {
            console.log("Handling server message:", message);
            const onlineOptionsDiv = document.getElementById('online-options');
            if (!serverMessageDisplay) serverMessageDisplay = document.getElementById('server-message-display'); // Ensure it's initialized

            switch (message.type) {
                case 'game_created':
                    sessionId = message.session_id;
                    playerId = message.player_id; // Server assigns 0 for RED, 1 for BLUE
                    isMultiplayerGame = true;
                    if (serverMessageDisplay) serverMessageDisplay.textContent = `Game Session ${sessionId} created! You are Player ${playerId === RED ? 'RED' : 'BLUE'}. Share ID: ${sessionId}. Waiting for opponent...`;
                    resetGame(); // Reset local board for a fresh start, server is truth
                    updateTurnIndicator(); // Reflect multiplayer status
                    if (onlineOptionsDiv) onlineOptionsDiv.style.display = 'none';
                    document.getElementById('new-game-btn').textContent = "Leave Game";
                    break;
                case 'player_joined': // For the player who just joined
                    sessionId = message.session_id;
                    playerId = message.player_id;
                    isMultiplayerGame = true;
                    if (serverMessageDisplay) serverMessageDisplay.textContent = `Successfully joined game ${sessionId}. You are Player ${playerId === RED ? 'RED' : 'BLUE'}. Waiting for game data...`;
                    resetGame(); 
                    updateTurnIndicator();
                    if (onlineOptionsDiv) onlineOptionsDiv.style.display = 'none';
                    document.getElementById('new-game-btn').textContent = "Leave Game";
                    break;
                case 'opponent_joined': // For the player who created the game
                    if (serverMessageDisplay) serverMessageDisplay.textContent = "Opponent joined! Game starting. Server will send initial state.";
                    // Server will typically follow up with a 'game_update'
                    break;
                case 'game_update':
                    board = message.board;
                    currentTurn = message.current_turn;
                    // Server scores are { "0": score, "1": score }
                    // Tessellate scores are products, ensure they are numbers
                    scores[RED] = Number(message.scores[RED.toString()]); 
                    scores[BLUE] = Number(message.scores[BLUE.toString()]);
                    gameOver = message.game_over_flag;
                    isMultiplayerGame = true; 

                    drawBoard();
                    updateScoreDisplay();
                    updateTurnIndicator(); 
                    
                    if (!gameOver) {
                        if (serverMessageDisplay) serverMessageDisplay.textContent = isMultiplayerGame ? `Game ${sessionId} in progress.` : "Local game.";
                    } else {
                         // If game_update indicates game over, but no specific winner yet in this message
                        if (!message.winner) { 
                            showGameOverMessage(); // Uses local scores which should now be updated from server
                        }
                    }
                    break;
                case 'game_over': 
                    gameOver = true;
                    isMultiplayerGame = true; 
                    if(message.scores) { // Update scores one last time if provided
                        scores[RED] = Number(message.scores[RED.toString()]);
                        scores[BLUE] = Number(message.scores[BLUE.toString()]);
                        updateScoreDisplay();
                    }

                    let winnerText = "Game Over. ";
                    if (message.winner === RED) winnerText += "Red wins!";
                    else if (message.winner === BLUE) winnerText += "Blue wins!";
                    else if (message.winner === "draw") winnerText += "It's a draw!";
                    else winnerText += "Game ended."; 
                    if (serverMessageDisplay) serverMessageDisplay.textContent = winnerText;
                    updateTurnIndicator(); 
                    canvas.style.cursor = 'default';
                    document.getElementById('new-game-btn').textContent = "New Game (Local)";
                    if (onlineOptionsDiv) onlineOptionsDiv.style.display = 'block'; // Allow new online game
                    break;
                case 'error':
                    if (serverMessageDisplay) serverMessageDisplay.textContent = `Error: ${message.message}`;
                    if (message.message.includes("Session not found") || message.message.includes("full")) {
                        if (onlineOptionsDiv) onlineOptionsDiv.style.display = 'block';
                    }
                    break;
                case 'opponent_disconnected': // This might be redundant if server sends game_over on disconnect-win
                    if (serverMessageDisplay && !gameOver) { // Only show if game isn't already marked over
                        serverMessageDisplay.textContent = "Opponent disconnected. Waiting for server update on game status...";
                    }
                    // Don't immediately set gameOver = true here if a game_over message is expected to follow.
                    // If game_over doesn't follow, socket.onclose will eventually handle UI cleanup.
                    // However, if this is the *only* message, then the game is effectively over.
                    // For robustness, let's assume this could be the only message for now if game doesn't end by win.
                    if (!gameOver) { // If game_over hasn't been declared by another message
                        // gameOver = true; // Server should be the source of truth for game_over if it's a win
                        // updateTurnIndicator();
                    }
                    // canvas.style.cursor = 'default'; // Let game_over or onclose handle this
                    // document.getElementById('new-game-btn').textContent = "New Game (Local)";
                    // if (onlineOptionsDiv) onlineOptionsDiv.style.display = 'block'; 
                    break;
                default:
                    console.warn("Unknown message type from server:", message.type);
                    if (serverMessageDisplay) serverMessageDisplay.textContent = `Received unknown message type: ${message.type}`;
            }
        }

         document.addEventListener('DOMContentLoaded', () => {
            serverMessageDisplay = document.getElementById('server-message-display'); // Initialize here
            initializeBoard();
            setupCanvas();
            updateScoreDisplay();
            updateTurnIndicator();

            canvas.addEventListener('click', handleClick);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseout', handleMouseOut);
            canvas.addEventListener('touchstart', (e) => {
                if (gameOver) return;
                e.preventDefault();
                handleMouseMove(e);
            }, { passive: false });
            canvas.addEventListener('touchend', (e) => {
                if (gameOver) return;
                const currentHover = hoverPosition;
                if (currentHover) {
                    handleClick(e);
                }
            }, { passive: false });

            // Updated new-game-btn logic for multiplayer context
            document.getElementById('new-game-btn').addEventListener('click', () => {
                const onlineOptionsDiv = document.getElementById('online-options');
                const newGameButton = document.getElementById('new-game-btn');

                if (isMultiplayerGame) {
                    // If in a multiplayer game, this button means "Leave Game"
                    if (serverMessageDisplay) serverMessageDisplay.textContent = "Left the online game. Switched to local mode.";
                    isMultiplayerGame = false; 
                    if (socket && socket.readyState === WebSocket.OPEN) {
                        // Consider sending a "leave_game" message to server if implemented
                        socket.close(); 
                        console.log("WebSocket connection closed by user action (Leave Game).");
                        socket = null; 
                    }
                    if (onlineOptionsDiv) onlineOptionsDiv.style.display = 'block'; // Show options to play online again
                    newGameButton.textContent = "New Game (Local)";
                    resetGame(); // Reset to a clean local state
                } else {
                    // If not in a multiplayer game, it's "New Game (Local)"
                    if (serverMessageDisplay) serverMessageDisplay.textContent = "New local game started.";
                     if (onlineOptionsDiv) onlineOptionsDiv.style.display = 'none'; // Ensure online options are hidden
                     newGameButton.textContent = "New Game (Local)"; // Ensure it says this
                     resetGame(); 
                }
                // updateTurnIndicator(); // resetGame calls this
            });
            document.getElementById('rules-btn').addEventListener('click', toggleRules);

            // Multiplayer UI event listeners
            const playOnlineBtn = document.getElementById('play-online-btn');
            const onlineOptionsDiv = document.getElementById('online-options');
            const createGameBtn = document.getElementById('create-game-btn');
            const joinGameBtn = document.getElementById('join-game-btn');
            const sessionIdInput = document.getElementById('session-id-input'); 

            // Initially disable online buttons until connection is established
            if (createGameBtn) createGameBtn.disabled = true;
            if (joinGameBtn) joinGameBtn.disabled = true;

            playOnlineBtn.addEventListener('click', () => {
                const currentlyVisible = onlineOptionsDiv.style.display === 'block';
                onlineOptionsDiv.style.display = currentlyVisible ? 'none' : 'block';
                
                if (onlineOptionsDiv.style.display === 'block') { // If panel is now visible
                    if (!socket || socket.readyState === WebSocket.CLOSED || socket.readyState === WebSocket.CLOSING) {
                        if (serverMessageDisplay) serverMessageDisplay.textContent = "Connecting to server...";
                        connectWebSocket(); // This will attempt to connect and update button states in onopen/onclose
                    } else if (socket.readyState === WebSocket.OPEN) {
                        if (serverMessageDisplay) serverMessageDisplay.textContent = "Connected. Choose an online option.";
                        if (createGameBtn) createGameBtn.disabled = false;
                        if (joinGameBtn) joinGameBtn.disabled = false;
                    } else if (socket.readyState === WebSocket.CONNECTING) {
                        if (serverMessageDisplay) serverMessageDisplay.textContent = "Still connecting...";
                        if (createGameBtn) createGameBtn.disabled = true;
                        if (joinGameBtn) joinGameBtn.disabled = true;
                    }
                }
            });

            createGameBtn.addEventListener('click', () => {
                initiateCreateGame(); 
            });

            joinGameBtn.addEventListener('click', () => {
                const joinId = sessionIdInput.value.trim(); 
                if (joinId) {
                    initiateJoinGame(joinId); 
                } else {
                    if (serverMessageDisplay) serverMessageDisplay.textContent = "Please enter a Session ID to join.";
                }
            });

            window.addEventListener('resize', () => {
                console.log("Window resized");
                setupCanvas();
            });
        });
    </script>
</body>
</html>
